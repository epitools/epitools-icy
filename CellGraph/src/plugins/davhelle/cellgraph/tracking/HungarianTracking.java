package plugins.davhelle.cellgraph.tracking;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import org.jgrapht.WeightedGraph;
import org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleWeightedGraph;

import plugins.davhelle.cellgraph.graphs.SpatioTemporalGraph;
import plugins.davhelle.cellgraph.nodes.ComparableNode;
import plugins.davhelle.cellgraph.nodes.DummyNode;
import plugins.davhelle.cellgraph.nodes.Node;

/**
 * 
 *  This implementation uses the so called "Hungarian" Graph
 *  matching algorithm. Implementation comes from the
 *  jgrapht.alg. package: 
 *  @see org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching;
 * 
 * @author Davide Heller
 *
 */
public class HungarianTracking extends GraphTracking{

	/**
	 * Dummy weight corresponding to the error generated by connecting it
	 */
	private Double dummy_weight;	
	
	/**
	 * Initializes Neighbor tracking
	 * 
	 * 
	 * @param spatioTemporalGraph Spatio-temporal graph to be tracked/linked
	 * @param linkrange the maximum no. of frames the node information is projected ahead
	 */
	public HungarianTracking(SpatioTemporalGraph spatioTemporalGraph, int linkrange, double lambda1, double lambda2) {
		super(spatioTemporalGraph, linkrange, lambda1, lambda2);
		this.dummy_weight = 30.0;
	}
	
	/**
	 * Linking algorithm based on the stable marriage problem. 
	 * The nodes in the current frame are addressed as "brides"
	 * while the brooms are the candidates from the first frame (except for divisions).
	 * 
	 * @param time_point of frame to be linked
	 * @return returns 2 Stacks containing the unlinked nodes, accessible trough a map interface ("brides", "grooms")
	 */
	public Map<String, Stack<Node>> linkCandidates(Map<Node, List<ComparableNode>> grooms,Map<Node, List<ComparableNode>> brides) {
		
		WeightedGraph<Node, DefaultWeightedEdge> cell_matching_bipartite_graph = 
				new SimpleWeightedGraph<Node, DefaultWeightedEdge>(DefaultWeightedEdge.class);
		
		//cost for non-assignment 100
		//dummy nodes are characterized by the TrackID(-10)
		for(Node node: grooms.keySet()){
			cell_matching_bipartite_graph.addVertex(node);
			//for all groom add a dummy brides
			DummyNode dummy_bride = new DummyNode();
			grooms.get(node).add(new ComparableNode(dummy_bride, dummy_weight));
			brides.put(dummy_bride, null);
			cell_matching_bipartite_graph.addVertex(dummy_bride);
		}
		
		for(Node node: brides.keySet()){
			cell_matching_bipartite_graph.addVertex(node);
			if(node.getTrackID() != -10){
				//for all real brides add a dummy groom
				DummyNode dummy_groom = new DummyNode();
				grooms.put(dummy_groom, null);
				cell_matching_bipartite_graph.addVertex(dummy_groom);
			}
		}
		
		//fill the complete and equal bipartite graph
		for(Node node: grooms.keySet())
		{
			if(grooms.get(node) != null)
			{
				for(ComparableNode match: grooms.get(node))
				{
					DefaultWeightedEdge candidate_edge = cell_matching_bipartite_graph.addEdge(node, match.getNode());
					cell_matching_bipartite_graph.setEdgeWeight(candidate_edge, match.getValue());
				}
			}
			
			for(Node bride: brides.keySet())
				if(!cell_matching_bipartite_graph.containsEdge(node, bride))
				{
					DefaultWeightedEdge candidate_edge = cell_matching_bipartite_graph.addEdge(node, bride);
					cell_matching_bipartite_graph.setEdgeWeight(candidate_edge, Double.MAX_VALUE);
				}
		}
		
		KuhnMunkresMinimalWeightBipartitePerfectMatching<Node, DefaultWeightedEdge> assignment_problem = 
				new KuhnMunkresMinimalWeightBipartitePerfectMatching<Node, DefaultWeightedEdge>(
						cell_matching_bipartite_graph,
						new ArrayList<Node>(grooms.keySet()),
						new ArrayList<Node>(brides.keySet()));
		
		Set<DefaultWeightedEdge> best_matches = assignment_problem.getMatching();

		//Initialize output data structures
		Stack<Node> unmarried_grooms = new Stack<Node>();
		Stack<Node> unmarried_brides = new Stack<Node>();

		//finally update node correspondences
		for(DefaultWeightedEdge match: best_matches){
			Node groom = cell_matching_bipartite_graph.getEdgeSource(match);
			Node bride = cell_matching_bipartite_graph.getEdgeTarget(match);
			
			boolean is_dummy_groom = (groom.getTrackID() == -10);
			boolean is_dummy_bride = (bride.getTrackID() == -10);
			
			if(is_dummy_bride && !is_dummy_groom)
				unmarried_grooms.push(groom);
			else if(!is_dummy_bride && is_dummy_groom)
				unmarried_brides.push(bride);
			else if(!is_dummy_bride && !is_dummy_groom)
				updateCorrespondence(bride, getMostRecentCorrespondence(bride, groom));
		}

		Map<String, Stack<Node>> unmarried = new HashMap<String, Stack<Node>>();
		unmarried.put("brides", unmarried_brides);
		unmarried.put("grooms", unmarried_grooms);
		
		return unmarried;
	}
	
}

